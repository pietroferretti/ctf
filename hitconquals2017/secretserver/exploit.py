# coding: utf-8

# MIT License
#
# Copyright (c) 2017 Pietro Ferretti
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from pwn import *
import base64, random, string
from Crypto.Hash import MD5, SHA256

def pad(msg):
    pad_length = 16-len(msg)%16
    return msg+chr(pad_length)*pad_length

def unpad(msg):
    return msg[:-ord(msg[-1])]

def xor_str(s1, s2):
    '''XOR between two strings. The longer one is truncated.'''
    return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(s1, s2))

def blockify(text, blocklen):
    '''Splits the text as a list of blocklen-long strings'''
    return [text[i:i+blocklen] for i in xrange(0, len(text), blocklen)]

def flipiv(oldplain, newplain, iv):
    '''Modifies an IV to produce the desired new plaintext in the following block'''
    flipmask = xor_str(oldplain, newplain)
    return xor_str(iv, flipmask)

def solve_proof(p):
    instructions = p.recvline().strip()
    suffix = instructions[12:28]
    print suffix
    digest = instructions[-64:]
    print digest
    prefix = ''.join(random.choice(string.ascii_letters+string.digits) for _ in xrange(4))
    newdigest = SHA256.new(prefix + suffix).hexdigest()
    while newdigest != digest:
        prefix = ''.join(random.choice(string.ascii_letters+string.digits) for _ in xrange(4))
        newdigest = SHA256.new(prefix + suffix).hexdigest()
    print 'POW:', prefix
    p.sendline(prefix)
    p.recvline()


HOST = '52.193.157.19'
PORT = 9999
welcomeplain = pad('Welcome!!')

p = remote(HOST, PORT)
solve_proof(p)

# get welcome
welcome = p.recvline(keepends=False)
print 'Welcome:', welcome
welcome_dec = base64.b64decode(welcome)
welcomeblocks = blockify(welcome_dec, 16)

# get command-not-found
p.sendline(welcome)
notfound = p.recvline(keepends=False)
print 'Command not found:', notfound

# get encrypted flag
payload = flipiv(welcomeplain, 'get-flag'.ljust(16, '\x01'), welcomeblocks[0])
payload += welcomeblocks[1]
p.sendline(base64.b64encode(payload))
flag = p.recvline(keepends=False)
print 'Flag:', flag
flag_dec = base64.b64decode(flag)
flagblocks = blockify(flag_dec, 16)
flaglen = len(flag_dec) - 16

known_flag = ''

def getmd5enc(i):
    '''Returns the md5 hash of the flag cut at index i, encrypted with AES and base64 encoded'''
    # replace beginning of flag with 'get-md5'
    payload = flipiv('hitcon{'.ljust(16, '\x00'), 'get-md5'.ljust(16, '\x00'), flagblocks[0])
    payload += ''.join(flagblocks[1:])
    # add a block where we control the last byte, to unpad at the correct length ('hitcon{' + i characters)
    payload += flipiv(welcomeplain, 'A'*15 + chr(16 + 16 + flaglen - 7 - 1 - i), welcomeblocks[0])
    payload += welcomeblocks[1]
    p.sendline(base64.b64encode(payload))
    md5b64 = p.recvline(keepends=False)
    return md5b64

for i in range(flaglen - 7):
    print '-- Character no. {} --'.format(i)
    # get md5 ciphertext for the flag up to index i
    newmd5 = getmd5enc(i)
    md5blocks = blockify(base64.b64decode(newmd5), 16)
    # try all possible characters for that index
    for guess in range(256):
        # locally compute md5 hash
        guess_md5 = MD5.new(known_flag + chr(guess)).digest()
        # try to null out the md5 plaintext and execute a command
        payload = flipiv(guess_md5, 'get-time'.ljust(16, '\x01'), md5blocks[0])
        payload += md5blocks[1]
        payload += md5blocks[2]    # padding block
        p.sendline(base64.b64encode(payload))
        res = p.recvline(keepends=False)

        # if we receive the block for 'command not found', the hash was wrong
        if res == notfound:
            print 'Guess {} is wrong.'.format(guess)
        # otherwise we correctly guessed the hash and the command was executed
        else:
            print 'Found!'
            known_flag += chr(guess)
            print 'Flag so far:', known_flag
            break

print 'hitcon{' + known_flag
